<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Pixel Platformer Part 3 | Ellies Blog</title>
<meta name="keywords" content="MonoGame, PixelPlatformer">
<meta name="description" content="Character selection &amp; Input! For Part 3 of this tutorial we will be diving into selecting the character we want to use from our spritesheet and the creation of our Input class.
I will start picking up the pace of explaining the code as we will soon be diving into a lot more code and it will help me if I explain a little quicker. Feel free to reach out to me on Discord if you need further explanations.">
<meta name="author" content="">
<link rel="canonical" href="http://elliemakesgames.net/posts/pixelplatformer3/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5b90f603e721c9591f92e42d19ae1c3113a2929e7366bea5977d446c153b4186.css" integrity="sha256-W5D2A&#43;chyVkfkuQtGa4cMROikp5zZr6ll31EbBU7QYY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://elliemakesgames.net/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://elliemakesgames.net/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://elliemakesgames.net/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://elliemakesgames.net/apple-touch-icon.png">
<link rel="mask-icon" href="http://elliemakesgames.net/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://elliemakesgames.net/posts/pixelplatformer3/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Pixel Platformer Part 3" />
<meta property="og:description" content="Character selection &amp; Input! For Part 3 of this tutorial we will be diving into selecting the character we want to use from our spritesheet and the creation of our Input class.
I will start picking up the pace of explaining the code as we will soon be diving into a lot more code and it will help me if I explain a little quicker. Feel free to reach out to me on Discord if you need further explanations." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://elliemakesgames.net/posts/pixelplatformer3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-04-08T19:30:50-03:00" />
<meta property="article:modified_time" content="2024-04-08T19:30:50-03:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Pixel Platformer Part 3"/>
<meta name="twitter:description" content="Character selection &amp; Input! For Part 3 of this tutorial we will be diving into selecting the character we want to use from our spritesheet and the creation of our Input class.
I will start picking up the pace of explaining the code as we will soon be diving into a lot more code and it will help me if I explain a little quicker. Feel free to reach out to me on Discord if you need further explanations."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://elliemakesgames.net/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Pixel Platformer Part 3",
      "item": "http://elliemakesgames.net/posts/pixelplatformer3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Pixel Platformer Part 3",
  "name": "Pixel Platformer Part 3",
  "description": "Character selection \u0026amp; Input! For Part 3 of this tutorial we will be diving into selecting the character we want to use from our spritesheet and the creation of our Input class.\nI will start picking up the pace of explaining the code as we will soon be diving into a lot more code and it will help me if I explain a little quicker. Feel free to reach out to me on Discord if you need further explanations.",
  "keywords": [
    "MonoGame", "PixelPlatformer"
  ],
  "articleBody": "Character selection \u0026 Input! For Part 3 of this tutorial we will be diving into selecting the character we want to use from our spritesheet and the creation of our Input class.\nI will start picking up the pace of explaining the code as we will soon be diving into a lot more code and it will help me if I explain a little quicker. Feel free to reach out to me on Discord if you need further explanations.\nCharacter selection So we need to select the character we want to use out of the atlas we previously rendered to the screen.\nTo do this we will use a different override for the Draw() Method. Specifically we will use the Draw(Texture2D texture, Vector2 position, Rectangle rectangle, Color color)\nRectangle? Whats that?\nThe Rectangle parameter we will use is specifically defined as the source rectangle. There is another rectanlge called the destination rectangle but we will not worry about that now. So the source rectangle will define a rectangle on our Texture2D atlas and render just what is inside that source rectangle.\nSo we will define a rectangle that takes in 4 parameters. The position x \u0026 y on our Texture2D and the width and height we want to render.\nReference the image below - our atlas is evenly divided into 24x24 for each sprite as shown with the grid\nSo lets say we want the red character for example. We need to find the X \u0026 Y value of the top left corner of that characters square on the grid.\nThis is the top left of the red characters square. So we can just use our art app to see what the X and Y value is: 96, 0 If you dont want to open an art app to see the exact value, since we know everything is spaced 24x24 we can just do some simple math: 24*4 \u0026 24*0 to get 96 \u0026 0\nNow that we have the X \u0026 Y 96, 0 we just need the width and height. Which we already know is 24x24. Perfect!\nThen you would just fill in the parameters of the Rectangle with these values.\nBut for this tutorial we will use the green character in the first 2 positions. so we will start with these values for our Rectangle: X \u0026 Y: 0, 0 and Width \u0026 Height: 24, 24.\nOkay lets create our variables:\nunderneath our _characterAtlas variable we will create the following:\nprivate Texture2D _characterAtlas; #region player private Rectangle _characterRect = new Rectangle(0,0,24,24); // private Vector2 _playerPosition = new Vector2(200, 200); #endregion The region is just for cleaniness - we will be moving everything to a Player class in an upcoming part.\nNow to just render this we will update our Draw() call to the following:\n_spriteBatch.Draw(_characterAtlas, _playerPosition, _characterRect, Color.White); You should now only see the character instead of the whole atlas! But it is still very very small. so we will quickly fix this now.\nSizing up the character For now for simplicity sake we will quickly adjust the players size. But this will soon be changed in an upcoming part so that everything will be sized up by default.\nTo do this is quite simple. We will just use the Scale parameter in the Draw() call. Though there are a couple other arguments aswell.\n_spriteBatch.Draw(_characterAtlas, _playerPosition, _characterRect, Color.White, 0f, Vector2.Zero, 2.5f, SpriteEffects.None, 0f); Updating our draw call to this line here will make the player 2.5 times bigger. the parameters of this override are as follows:\nDraw(Texture2D texture, Vector2 position, Rectangle sourceRectangle, Color color, float rotation, Vector2 origin, float scale, SpriteEffects spriteEffects, float layerDepth)\nWe will set the roation to 0f, origin to Vector2.Zero, Scale to 2.5f, SpriteEffects to SpriteEffects.None, and layerDepth to 0f. Most of these are self explanitory but we will go over them when we use them.\nYou should now see the character and he‚Äôs bigger now! WooHoo! Now lets make him move!\nMoving the character To begin moving the character we need to poll for input from our game. To do so we will create a seperate Input class.\nCreate the following folder and file structure:\n‚îî‚îÄ‚îÄ üìÅSrc ‚îî‚îÄ‚îÄ üìÅUtil ‚îî‚îÄ‚îÄ Input.cs Lets create our class! start with the basic outline of the class:\nusing System; using System.Linq; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Input; namespace PixelPlatformer.Util; public static class Input { } We will create this class in the namespace namespace PixelPlatformer.Util\nThe variables we need for this class are the following:\npublic static class Input { private static KeyboardState _currentKeyboard; private static KeyboardState _previousKeyboard; private static int[] _keyCodes; private static bool[] _keyPress; private static bool[] _keyDown; } We will need to capture the current frames state and the previous frame state of our keyboard to determine if a key is held vs pressed.\nWe will create 3 Arrays to hold the data of all our key codes as ints - a bool array for pressed keys and a bool array of held down keys.\nWe will also need the following functions\npublic static class Input { private static KeyboardState _currentKeyboard; private static KeyboardState _previousKeyboard; private static int[] _keyCodes; private static bool[] _keyPress; private static bool[] _keyDown; public static void Initialize(){ } public static void Update(GameTime gameTime){ } public static bool IsKeyPressed(Keys key){ } public static bool IsKeyDown(Keys key){ } } These 4 functions are all we need to get basic keyboard input from across our game.\nInitialize will initialize our arrays Update will check our keyboard every frame and update its state IsKeyPressed will return true or false if a key is just pressed IsKeyDown will return true or false if a key is held down Lets start with initialize\npublic static void Initialize(){ _keyCodes = Enum.GetValues(typeof(Keys)).Cast\u003cint\u003e().ToArray(); _keyPress = new bool[_keyCodes.Length]; _keyDown = new bool[_keyCodes.Length]; } We will initialize our arrays.\n_keyCodes = Enum.GetValues(typeof(Keys)).Cast().ToArray(); this will convert MonoGames enum Keys to their respective integer values of the enum _keyPress = new bool[_keyCodes.Length]; we will initialize _keyPress with the size of how many keys codes we have _keyDown = new bool[_keyCodes.Length]; we will initialize _keyDown with the size of how many keys codes we have Update\npublic static void Update(GameTime gameTime){ _currentKeyboard = Keyboard.GetState(); for(int i = 0; i \u003c _keyCodes.Length; i++){ Keys key = (Keys)_keyCodes[i]; if(_currentKeyboard.IsKeyDown(key) \u0026\u0026 !_previousKeyboard.IsKeyDown(key)){ _keyPress[i] = true; } else { _keyPress[i] = false; } if(_currentKeyboard.IsKeyDown(key) \u0026\u0026 _previousKeyboard.IsKeyDown(key)){ _keyDown[i] = true; } else { _keyDown[i] = false; } } _previousKeyboard = Keyboard.GetState(); } Slightly more complex. We will first capture the keyboards state this frame _currentKeyboard = Keyboard.GetState();\nWe will then loop with the for() loop to check all our keys.\nWe will now cast the key to the enum value Keys key = (Keys)_keyCodes[i]; so if i = 0 it will set key = the first enum value note that the enum is a list of all keyboard keys which is provided by MonoGame in the using Microsoft.Xna.Framework.Input;\nif(_currentKeyboard.IsKeyDown(key) \u0026\u0026 !_previousKeyboard.IsKeyDown(key)) this if statement will check the current keyabord if KeyIsDown and it will check the previous keyboard if the key was NOT down.\nExample: frame 100 of our game running we are not pressing A on the keyboard and then on frame 101 we press A then this if statement will return true.\nWe then set the key in our _keyPress[] to true using i since i corresponds to the position of the key in our array\nExample: _keyPress is filled with our keycodes enum. Lets say our enum has 4 keys W, A, S, D in initialize we are setting _keyPress[] to the size of our enum _keyPress = new bool[_keyCodes.Length]; so since its a bool array our array looks like this [0, 0, 0, 0] with each position representing the enum. so position 0 = W, 1 = A, etc‚Ä¶ Looping through the key codes - for this example the enum is W, A, S, D it will loop through them in that order. it will check IsKeyDown(W) and so on throughout our for loop. So lets say we press A it will check IsKeyDown(W) which is false. Next iteration it will check IsKeyDown(A) true! so we set _keyPress[i] = true so our array now looks like [0, 1, 0, 0].\nThis was a simple example as MonoGame covers all keys there are a lot more keys defined within monogame - but this is the basic idea of what we are implementing.\nWe will then just check if current state is Down and the previous state is also Down we will the set our _keyDown[] array to true or false if(_currentKeyboard.IsKeyDown(key) \u0026\u0026 _previousKeyboard.IsKeyDown(key))\nDont forget to set to false if these conditions do not match the expressions.\nAnd to end the update frame we will set prev keyboard to this frames state so the next frame can use the data for its if checks _previousKeyboard = Keyboard.GetState();\nThis is simplier then it looks but trust me it will make using input a lot easier for us!\nThe next two functions are just to check if the key is pressed or held down\npublic static bool IsKeyPressed(Keys key){ int i = Array.FindIndex(_keyCodes, x =\u003e x == (int)key); return _keyPress[i]; } public static bool IsKeyDown(Keys key){ int i = Array.FindIndex(_keyCodes, x =\u003e x == (int)key); return _keyDown[i]; } This is pretty self explanitory - we are just checking if the key we specify is true or false in our 2 bool arrays we made for pressed \u0026 down.\nFull class:\nusing System; using System.Linq; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Input; namespace PixelPlatformer.Util; public static class Input { private static KeyboardState _currentKeyboard; private static KeyboardState _previousKeyboard; private static int[] _keyCodes; private static bool[] _keyPress; private static bool[] _keyDown; public static void Initialize(){ _keyCodes = Enum.GetValues(typeof(Keys)).Cast\u003cint\u003e().ToArray(); _keyPress = new bool[_keyCodes.Length]; _keyDown = new bool[_keyCodes.Length]; } public static void Update(GameTime gameTime){ _currentKeyboard = Keyboard.GetState(); for(int i = 0; i \u003c _keyCodes.Length; i++){ Keys key = (Keys)_keyCodes[i]; if(_currentKeyboard.IsKeyDown(key) \u0026\u0026 !_previousKeyboard.IsKeyDown(key)){ _keyPress[i] = true; } else { _keyPress[i] = false; } if(_currentKeyboard.IsKeyDown(key) \u0026\u0026 _previousKeyboard.IsKeyDown(key)){ _keyDown[i] = true; } else { _keyDown[i] = false; } } _previousKeyboard = Keyboard.GetState(); } public static bool IsKeyPressed(Keys key){ int i = Array.FindIndex(_keyCodes, x =\u003e x == (int)key); return _keyPress[i]; } public static bool IsKeyDown(Keys key){ int i = Array.FindIndex(_keyCodes, x =\u003e x == (int)key); return _keyDown[i]; } } Great! now lets use this class in our main Game class.\nDON‚ÄôT MISS THIS STEP Don‚Äôt forget to call our Initialize() and Update() in our main games Initialize and Update functions\nprotected override void Initialize() { _graphics.PreferredBackBufferWidth = 1280; _graphics.PreferredBackBufferHeight = 720; _graphics.ApplyChanges(); Window.AllowUserResizing = false; Input.Initialize(); base.Initialize(); } protected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit(); // TODO: Add your update logic here Input.Update(gameTime); base.Update(gameTime); } Using our new Input class Lets move the character with our Input class now!\nFirst we will add a couple variables for our players magnitude \u0026 speed:\n#region player private Rectangle _characterRect = new Rectangle(0,0,24,24); // private Vector2 _playerPosition = new Vector2(200, 200); private Vector2 _playerMagnitude = Vector2.Zero; private float _playerSpeed = 6.0f; #endregion in our update function we will do the following: Make sure to do it AFTER calling Update()\nInput.Update(gameTime); _playerMagnitude = Vector2.Zero; if(Input.IsKeyDown(Keys.A)){ _playerMagnitude.X = -1; } if (Input.IsKeyDown(Keys.D)) { _playerMagnitude.X = 1; } _playerPosition.X += _playerMagnitude.X * _playerSpeed; _playerMagnitude = Vector2.Zero; set magnitude to Vector2.Zero at the beginning of a frame If statements to check our keys to see if they are pressed down. and setting the X magnitude to -1 for left and 1 for right if(Input.IsKeyDown(Keys.A)){ _playerMagnitude.X = -1; } if (Input.IsKeyDown(Keys.D)) { _playerMagnitude.X = 1; } _playerPosition.X += _playerMagnitude.X * _playerSpeed; we will then set our positions X by adding the previous X value + the magnitude * by the speed. So if magnitude is -1 when holding left we will move the player -1 * 6.0f = -6.0f so we take the previous X 200 and add -6.0 so we will move to 194 and positive value for right. Running the game now we should now be able to move left and right with our player pressing A \u0026 D!\nConclusion If you made it to here CONGRATS! this was a lengthy Part but we made lots of progress! we can now move the player! woohoo!\nThe next part we will be preparing to adding more movement to our player for falling down with gravity and also flipping the character depending on the direction we press!\nCommon errors If your character is not moving when pressing the keys make sure you are calling initialize and update functions. I highly suggest looking through this part a second time to make sure you didnt miss any small details\nIf you still have any trouble please post in the Github Disscusion or message me privately on discord! tag: ellie.x3\nComplete source code\n",
  "wordCount" : "2127",
  "inLanguage": "en",
  "datePublished": "2024-04-08T19:30:50-03:00",
  "dateModified": "2024-04-08T19:30:50-03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://elliemakesgames.net/posts/pixelplatformer3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ellies Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://elliemakesgames.net/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://elliemakesgames.net/" accesskey="h" title="Ellies Blog (Alt + H)">Ellies Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://elliemakesgames.net/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://elliemakesgames.net/">Home</a>&nbsp;¬ª&nbsp;<a href="http://elliemakesgames.net/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Pixel Platformer Part 3
    </h1>
    <div class="post-meta"><span title='2024-04-08 19:30:50 -0300 ADT'>April 8, 2024</span>&nbsp;¬∑&nbsp;10 min

</div>
  </header> 
  <div class="post-content"><h1 id="character-selection--input">Character selection &amp; Input!<a hidden class="anchor" aria-hidden="true" href="#character-selection--input">#</a></h1>
<p>For Part 3 of this tutorial we will be diving into selecting the character we want to use from our spritesheet and the creation of our Input class.</p>
<p>I will start picking up the pace of explaining the code as we will soon be diving into a lot more code and it will help me if I explain a little quicker. Feel free to reach out to me on Discord if you need further explanations.</p>
<h1 id="character-selection">Character selection<a hidden class="anchor" aria-hidden="true" href="#character-selection">#</a></h1>
<p>So we need to select the character we want to use out of the atlas we previously rendered to the screen.</p>
<p>To do this we will use a different override for the <code>Draw()</code> Method. Specifically we will use the <code>Draw(Texture2D texture, Vector2 position, Rectangle rectangle, Color color)</code></p>
<p>Rectangle? Whats that?</p>
<p>The Rectangle parameter we will use is specifically defined as the source rectangle. There is another rectanlge called the destination rectangle but we will not worry about that now. So the source rectangle will define a rectangle on our Texture2D atlas and render just what is inside that source rectangle.</p>
<p>So we will define a rectangle that takes in 4 parameters. The position x &amp; y on our Texture2D and the width and height we want to render.</p>
<p>Reference the image below - our atlas is evenly divided into 24x24 for each sprite as shown with the grid</p>
<p><img loading="lazy" src="/imgs/PixelPlatformer/grid.png" alt="Grids"  />
</p>
<p>So lets say we want the red character for example. We need to find the X &amp; Y value of the top left corner of that characters square on the grid.</p>
<p><img loading="lazy" src="/imgs/PixelPlatformer/griddot.png" alt="Grid dot"  />
</p>
<p>This is the top left of the red characters square. So we can just use our art app to see what the X and Y value is: <code>96, 0</code> If you dont want to open an art app to see the exact value, since we know everything is spaced 24x24 we can just do some simple math: 24*4 &amp; 24*0 to get 96 &amp; 0</p>
<p><img loading="lazy" src="/imgs/PixelPlatformer/gridmath.png" alt="Grid math"  />
</p>
<p>Now that we have the X &amp; Y <code>96, 0</code> we just need the width and height. Which we already know is 24x24. Perfect!</p>
<p>Then you would just fill in the parameters of the Rectangle with these values.</p>
<p>But for this tutorial we will use the green character in the first 2 positions. so we will start with these values for our Rectangle: X &amp; Y: 0, 0 and Width &amp; Height: 24, 24.</p>
<hr>
<p>Okay lets create our variables:</p>
<p>underneath our <code>_characterAtlas</code> variable we will create the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Texture2D _characterAtlas; 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#region</span> player
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Rectangle _characterRect = <span style="color:#66d9ef">new</span> Rectangle(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">24</span>,<span style="color:#ae81ff">24</span>); //
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Vector2 _playerPosition = <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">200</span>, <span style="color:#ae81ff">200</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#endregion</span>
</span></span></code></pre></div><p>The region is just for cleaniness - we will be moving everything to a Player class in an upcoming part.</p>
<p>Now to just render this we will update our <code>Draw()</code> call to the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>    _spriteBatch.Draw(_characterAtlas, _playerPosition, _characterRect, Color.White);
</span></span></code></pre></div><p>You should now only see the character instead of the whole atlas! But it is still very very small. so we will quickly fix this now.</p>
<h1 id="sizing-up-the-character">Sizing up the character<a hidden class="anchor" aria-hidden="true" href="#sizing-up-the-character">#</a></h1>
<p>For now for simplicity sake we will quickly adjust the players size. But this will soon be changed in an upcoming part so that everything will be sized up by default.</p>
<p>To do this is quite simple. We will just use the Scale parameter in the <code>Draw()</code> call. Though there are a couple other arguments aswell.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>    _spriteBatch.Draw(_characterAtlas, _playerPosition, _characterRect, Color.White, <span style="color:#ae81ff">0f</span>, Vector2.Zero, <span style="color:#ae81ff">2.5f</span>, SpriteEffects.None, <span style="color:#ae81ff">0f</span>);
</span></span></code></pre></div><p>Updating our draw call to this line here will make the player 2.5 times bigger. the parameters of this override are as follows:</p>
<p><code>Draw(Texture2D texture, Vector2 position, Rectangle sourceRectangle, Color color, float rotation, Vector2 origin, float scale, SpriteEffects spriteEffects, float layerDepth)</code></p>
<p>We will set the roation to 0f, origin to Vector2.Zero, Scale to 2.5f, SpriteEffects to SpriteEffects.None, and layerDepth to 0f. Most of these are self explanitory but we will go over them when we use them.</p>
<p>You should now see the character and he&rsquo;s bigger now! WooHoo! Now lets make him move!</p>
<h1 id="moving-the-character">Moving the character<a hidden class="anchor" aria-hidden="true" href="#moving-the-character">#</a></h1>
<p>To begin moving the character we need to poll for input from our game. To do so we will create a seperate <code>Input</code> class.</p>
<p>Create the following folder and file structure:</p>
<pre tabindex="0"><code>‚îî‚îÄ‚îÄ üìÅSrc
    ‚îî‚îÄ‚îÄ üìÅUtil
        ‚îî‚îÄ‚îÄ Input.cs
</code></pre><p>Lets create our class! start with the basic outline of the class:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System.Linq;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> Microsoft.Xna.Framework;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> Microsoft.Xna.Framework.Input;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> PixelPlatformer.Util;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Input</span> {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We will create this class in the namespace <code>namespace PixelPlatformer.Util</code></p>
<p>The variables we need for this class are the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Input</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> KeyboardState _currentKeyboard;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> KeyboardState _previousKeyboard;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>[] _keyCodes;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span>[] _keyPress;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span>[] _keyDown;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We will need to capture the current frames state and the previous frame state of our keyboard to determine if a key is held vs pressed.</p>
<p>We will create 3 Arrays to hold the data of all our key codes as ints - a bool array for pressed keys and a bool array of held down keys.</p>
<p>We will also need the following functions</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Input</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> KeyboardState _currentKeyboard;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> KeyboardState _previousKeyboard;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>[] _keyCodes;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span>[] _keyPress;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span>[] _keyDown;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Initialize(){
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime){
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> IsKeyPressed(Keys key){
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> IsKeyDown(Keys key){
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>These 4 functions are all we need to get basic keyboard input from across our game.</p>
<ul>
<li><code>Initialize</code> will initialize our arrays</li>
<li><code>Update</code> will check our keyboard every frame and update its state</li>
<li><code>IsKeyPressed</code> will return true or false if a key is just pressed</li>
<li><code>IsKeyDown</code> will return true or false if a key is held down</li>
</ul>
<p>Lets start with initialize</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Initialize(){
</span></span><span style="display:flex;"><span>        _keyCodes = Enum.GetValues(<span style="color:#66d9ef">typeof</span>(Keys)).Cast&lt;<span style="color:#66d9ef">int</span>&gt;().ToArray();
</span></span><span style="display:flex;"><span>        _keyPress = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">bool</span>[_keyCodes.Length];
</span></span><span style="display:flex;"><span>        _keyDown = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">bool</span>[_keyCodes.Length];
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>We will initialize our arrays.</p>
<ul>
<li><code>_keyCodes = Enum.GetValues(typeof(Keys)).Cast&lt;int&gt;().ToArray();</code> this will convert MonoGames enum <code>Keys</code> to their respective integer values of the enum</li>
<li><code>_keyPress = new bool[_keyCodes.Length];</code> we will initialize <code>_keyPress</code> with the size of how many keys codes we have</li>
<li><code>_keyDown = new bool[_keyCodes.Length];</code> we will initialize <code>_keyDown</code> with the size of how many keys codes we have</li>
</ul>
<p>Update</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime){
</span></span><span style="display:flex;"><span>        _currentKeyboard = Keyboard.GetState();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; _keyCodes.Length; i++){
</span></span><span style="display:flex;"><span>            Keys key = (Keys)_keyCodes[i];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(_currentKeyboard.IsKeyDown(key) &amp;&amp; !_previousKeyboard.IsKeyDown(key)){
</span></span><span style="display:flex;"><span>                _keyPress[i] = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                _keyPress[i] = <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(_currentKeyboard.IsKeyDown(key) &amp;&amp; _previousKeyboard.IsKeyDown(key)){
</span></span><span style="display:flex;"><span>                _keyDown[i] = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                _keyDown[i] = <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        _previousKeyboard = Keyboard.GetState();
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Slightly more complex. We will first capture the keyboards state this frame <code>_currentKeyboard = Keyboard.GetState();</code></p>
<p>We will then loop with the <code>for()</code> loop to check all our keys.</p>
<p>We will now cast the key to the enum value <code>Keys key = (Keys)_keyCodes[i];</code> so if <code>i = 0</code> it will set <code>key = the first enum value</code> note that the enum is a list of all keyboard keys which is provided by MonoGame in the <code>using Microsoft.Xna.Framework.Input;</code></p>
<p><code>if(_currentKeyboard.IsKeyDown(key) &amp;&amp; !_previousKeyboard.IsKeyDown(key))</code> this if statement will check the current keyabord if <code>KeyIsDown</code> and it will check the previous keyboard if the key was <strong>NOT</strong> down.</p>
<p>Example: frame 100 of our game running we are not pressing <code>A</code> on the keyboard and then on frame 101 we press <code>A</code> then this if statement will return true.</p>
<p>We then set the key in our <code>_keyPress[]</code> to true using <code>i</code> since i corresponds to the position of the key in our array</p>
<p>Example: _keyPress is filled with our keycodes enum. Lets say our enum has 4 keys <code>W, A, S, D</code> in initialize we are setting _keyPress[] to the size of our enum <code>_keyPress = new bool[_keyCodes.Length];</code> so since its a bool array our array looks like this <code>[0, 0, 0, 0]</code> with each position representing the enum. so position 0 = W, 1 = A, etc&hellip; Looping through the key codes - for this example the enum is <code>W, A, S, D</code> it will loop through them in that order. it will check <code>IsKeyDown(W)</code> and so on throughout our for loop. So lets say we press <code>A</code> it will check <code>IsKeyDown(W)</code> which is false. Next iteration it will check <code>IsKeyDown(A)</code> true! so we set <code>_keyPress[i] = true</code> so our array now looks like [0, 1, 0, 0].</p>
<p>This was a simple example as MonoGame covers all keys there are a lot more keys defined within monogame - but this is the basic idea of what we are implementing.</p>
<p>We will then just check if current state is Down and the previous state is also Down we will the set our <code>_keyDown[]</code> array to true or false
<code>if(_currentKeyboard.IsKeyDown(key) &amp;&amp; _previousKeyboard.IsKeyDown(key))</code></p>
<p>Dont forget to set to false if these conditions do not match the expressions.</p>
<p>And to end the update frame we will set prev keyboard to this frames state so the next frame can use the data for its if checks
<code>_previousKeyboard = Keyboard.GetState();</code></p>
<p>This is simplier then it looks but trust me it will make using input a lot easier for us!</p>
<p>The next two functions are just to check if the key is pressed or held down</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> IsKeyPressed(Keys key){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i = Array.FindIndex(_keyCodes, x =&gt; x == (<span style="color:#66d9ef">int</span>)key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> _keyPress[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> IsKeyDown(Keys key){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i = Array.FindIndex(_keyCodes, x =&gt; x == (<span style="color:#66d9ef">int</span>)key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> _keyDown[i];
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>This is pretty self explanitory - we are just checking if the key we specify is true or false in our 2 bool arrays we made for pressed &amp; down.</p>
<p>Full class:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System.Linq;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> Microsoft.Xna.Framework;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> Microsoft.Xna.Framework.Input;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> PixelPlatformer.Util;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Input</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> KeyboardState _currentKeyboard;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> KeyboardState _previousKeyboard;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span>[] _keyCodes;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span>[] _keyPress;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span>[] _keyDown;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Initialize(){
</span></span><span style="display:flex;"><span>        _keyCodes = Enum.GetValues(<span style="color:#66d9ef">typeof</span>(Keys)).Cast&lt;<span style="color:#66d9ef">int</span>&gt;().ToArray();
</span></span><span style="display:flex;"><span>        _keyPress = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">bool</span>[_keyCodes.Length];
</span></span><span style="display:flex;"><span>        _keyDown = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">bool</span>[_keyCodes.Length];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime){
</span></span><span style="display:flex;"><span>        _currentKeyboard = Keyboard.GetState();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; _keyCodes.Length; i++){
</span></span><span style="display:flex;"><span>            Keys key = (Keys)_keyCodes[i];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(_currentKeyboard.IsKeyDown(key) &amp;&amp; !_previousKeyboard.IsKeyDown(key)){
</span></span><span style="display:flex;"><span>                _keyPress[i] = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                _keyPress[i] = <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(_currentKeyboard.IsKeyDown(key) &amp;&amp; _previousKeyboard.IsKeyDown(key)){
</span></span><span style="display:flex;"><span>                _keyDown[i] = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                _keyDown[i] = <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        _previousKeyboard = Keyboard.GetState();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> IsKeyPressed(Keys key){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i = Array.FindIndex(_keyCodes, x =&gt; x == (<span style="color:#66d9ef">int</span>)key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> _keyPress[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> IsKeyDown(Keys key){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i = Array.FindIndex(_keyCodes, x =&gt; x == (<span style="color:#66d9ef">int</span>)key);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> _keyDown[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Great! now lets use this class in our main Game class.</p>
<h2 id="dont-miss-this-step"><strong>DON&rsquo;T MISS THIS STEP</strong><a hidden class="anchor" aria-hidden="true" href="#dont-miss-this-step">#</a></h2>
<p>Don&rsquo;t forget to call our <code>Initialize()</code> and <code>Update()</code> in our main games Initialize and Update functions</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Initialize()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _graphics.PreferredBackBufferWidth = <span style="color:#ae81ff">1280</span>;
</span></span><span style="display:flex;"><span>        _graphics.PreferredBackBufferHeight = <span style="color:#ae81ff">720</span>;
</span></span><span style="display:flex;"><span>        _graphics.ApplyChanges();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Window.AllowUserResizing = <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Input.Initialize();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">base</span>.Initialize();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))
</span></span><span style="display:flex;"><span>            Exit();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// TODO: Add your update logic here</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Input.Update(gameTime);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">base</span>.Update(gameTime);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h1 id="using-our-new-input-class">Using our new Input class<a hidden class="anchor" aria-hidden="true" href="#using-our-new-input-class">#</a></h1>
<p>Lets move the character with our Input class now!</p>
<p>First we will add a couple variables for our players magnitude &amp; speed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>    <span style="color:#75715e">#region</span> player
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Rectangle _characterRect = <span style="color:#66d9ef">new</span> Rectangle(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">24</span>,<span style="color:#ae81ff">24</span>); //
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Vector2 _playerPosition = <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">200</span>, <span style="color:#ae81ff">200</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Vector2 _playerMagnitude = Vector2.Zero;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">float</span> _playerSpeed = <span style="color:#ae81ff">6.0f</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">#endregion</span>
</span></span></code></pre></div><p>in our update function we will do the following: <strong>Make sure to do it AFTER calling Update()</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>        Input.Update(gameTime);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        _playerMagnitude = Vector2.Zero;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(Input.IsKeyDown(Keys.A)){
</span></span><span style="display:flex;"><span>            _playerMagnitude.X = -<span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (Input.IsKeyDown(Keys.D)) {
</span></span><span style="display:flex;"><span>            _playerMagnitude.X = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        _playerPosition.X += _playerMagnitude.X * _playerSpeed;
</span></span></code></pre></div><ul>
<li><code>_playerMagnitude = Vector2.Zero;</code> set magnitude to Vector2.Zero at the beginning of a frame</li>
<li>If statements to check our keys to see if they are pressed down. and setting the X magnitude to -1 for left and 1 for right</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(Input.IsKeyDown(Keys.A)){
</span></span><span style="display:flex;"><span>        _playerMagnitude.X = -<span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Input.IsKeyDown(Keys.D)) {
</span></span><span style="display:flex;"><span>        _playerMagnitude.X = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><ul>
<li><code>_playerPosition.X += _playerMagnitude.X * _playerSpeed;</code> we will then set our positions X by adding the previous X value + the magnitude * by the speed. So if magnitude is -1 when holding left we will move the player <code>-1 * 6.0f = -6.0f</code> so we take the previous X <code>200</code> and add <code>-6.0</code> so we will move to <code>194</code> and positive value for right.</li>
</ul>
<p>Running the game now we should now be able to move left and right with our player pressing A &amp; D!</p>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>If you made it to here CONGRATS! this was a lengthy Part but we made lots of progress! we can now move the player! woohoo!</p>
<p>The next part we will be preparing to adding more movement to our player for falling down with gravity and also flipping the character depending on the direction we press!</p>
<h1 id="common-errors">Common errors<a hidden class="anchor" aria-hidden="true" href="#common-errors">#</a></h1>
<p>If your character is not moving when pressing the keys make sure you are calling initialize and update functions.
I highly suggest looking through this part a second time to make sure you didnt miss any small details</p>
<p>If you still have any trouble please post in the <a href="https://github.com/MonoGame/MonoGame/discussions/8271">Github Disscusion</a> or message me privately on discord! tag: ellie.x3</p>
<p><a href="https://github.com/Ellie-x3/PlatformerTutorial">Complete source code</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://elliemakesgames.net/tags/monogame/">MonoGame</a></li>
      <li><a href="http://elliemakesgames.net/tags/pixelplatformer/">PixelPlatformer</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://elliemakesgames.net/">Ellies Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
